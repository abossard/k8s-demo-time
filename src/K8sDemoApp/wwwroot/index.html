<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>K8s Demo App</title>
  <style>
    :root {
      color-scheme: light dark;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      color: #f1f5f9;
      --host-color-primary: #38bdf8;
      --host-color-glow: rgba(56, 189, 248, 0.3);
      --host-color-surface: rgba(15, 23, 42, 0.82);
      --host-color-border: rgba(148, 163, 184, 0.25);
      --host-color-dark: #0f172a;
      --host-color-darker: #0b1120;
      --host-color-chip: rgba(56, 189, 248, 0.18);
      --host-color-chip-border: rgba(56, 189, 248, 0.4);
      --host-color-button: #3b82f6;
      --host-color-button-hover: #60a5fa;
    }

    body {
      margin: 0;
      padding: 1.5rem;
      display: grid;
      gap: 1.5rem;
      min-height: 100vh;
      background:
        radial-gradient(circle at 20% -10%, var(--host-color-glow), transparent 55%),
        radial-gradient(circle at 80% -20%, rgba(248, 250, 252, 0.08), transparent 45%),
        linear-gradient(180deg, var(--host-color-dark), var(--host-color-darker));
      transition: background 250ms ease;
    }

    main {
      max-width: 960px;
      margin: 0 auto;
      display: grid;
      gap: 1.5rem;
    }

    header h1 {
      margin: 0;
      font-size: clamp(2rem, 4vw, 2.75rem);
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: var(--host-color-primary);
      text-shadow: 0 0 25px var(--host-color-glow);
    }

    section {
      background: var(--host-color-surface);
      padding: 1.35rem;
      border-radius: 0.85rem;
      border: 1px solid var(--host-color-border);
      box-shadow: 0 25px 50px -18px var(--host-color-glow);
      backdrop-filter: blur(14px);
    }

    h2 {
      margin-top: 0;
      font-size: 1.25rem;
      letter-spacing: 0.02em;
    }

    .grid {
      display: grid;
      gap: 1rem;
    }

    .probe {
      display: grid;
      gap: 0.5rem;
    }

    .probe-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.75rem;
    }

    .probe-name {
      font-weight: 600;
      color: rgba(226, 232, 240, 0.92);
    }

    .probe-metrics {
      display: flex;
      gap: 1rem;
      flex-wrap: wrap;
      font-size: 0.8rem;
      color: rgba(226, 232, 240, 0.6);
    }

    .flex {
      display: flex;
      gap: 0.75rem;
      flex-wrap: wrap;
      align-items: center;
    }

    label {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.95rem;
    }

    input {
      padding: 0.4rem 0.6rem;
      border-radius: 0.4rem;
      border: 1px solid rgba(148, 163, 184, 0.3);
      background: rgba(8, 15, 30, 0.65);
      color: inherit;
      width: 6rem;
    }

    button {
      padding: 0.45rem 0.85rem;
      border-radius: 0.55rem;
      border: 1px solid transparent;
      background: var(--host-color-button);
      color: #fff;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.1s ease, box-shadow 0.1s ease, background 0.15s ease;
    }

    button.secondary {
      background: rgba(148, 163, 184, 0.18);
      color: inherit;
    }

    button.ghost {
      background: transparent;
      color: rgba(226, 232, 240, 0.7);
      border-color: var(--host-color-border);
    }

    button:hover {
      transform: translateY(-1px);
      background: var(--host-color-button-hover);
      box-shadow: 0 10px 20px -12px var(--host-color-glow);
    }

    button.ghost:hover {
      background: rgba(148, 163, 184, 0.16);
      color: var(--host-color-primary);
      box-shadow: none;
    }

    .status-card {
      display: grid;
      gap: 0.75rem;
      padding: 1rem;
      border-radius: 0.65rem;
      background: rgba(9, 16, 30, 0.65);
      border: 1px solid var(--host-color-border);
    }

    .status-chip {
      display: inline-flex;
      align-items: center;
      gap: 0.4rem;
      padding: 0.25rem 0.6rem;
      border-radius: 9999px;
      font-size: 0.85rem;
      font-weight: 600;
      border: 1px solid transparent;
    }

    .status-chip.up {
      background: var(--host-color-chip);
      color: var(--host-color-button-hover);
      border-color: var(--host-color-chip-border);
    }

    .status-chip.down {
      background: rgba(248, 113, 113, 0.2);
      color: #fca5a5;
      border: 1px solid rgba(248, 113, 113, 0.4);
    }

    #notifications {
      min-height: 1.2rem;
      font-size: 0.95rem;
    }

    .instance-card {
      gap: 1rem;
    }

    .host-banner {
      display: flex;
      flex-direction: column;
      gap: 0.35rem;
    }

    .host-label {
      text-transform: uppercase;
      letter-spacing: 0.2em;
      font-size: 0.75rem;
      color: rgba(226, 232, 240, 0.7);
    }

    #hostname {
      display: block;
      font-size: clamp(2.5rem, 7vw, 4.5rem);
      font-weight: 800;
      letter-spacing: 0.05em;
      color: var(--host-color-primary);
      text-shadow: 0 0 55px var(--host-color-glow);
      word-break: break-word;
    }

    .meta-grid {
      display: grid;
      gap: 0.85rem;
      grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
    }

    .meta-item {
      display: grid;
      gap: 0.2rem;
    }

    .meta-label {
      text-transform: uppercase;
      letter-spacing: 0.18em;
      font-size: 0.7rem;
      color: rgba(226, 232, 240, 0.6);
    }

    .meta-value {
      font-size: 1.05rem;
      font-weight: 600;
    }

    @media (max-width: 640px) {
      input {
        width: 100%;
      }

      label {
        width: 100%;
        justify-content: space-between;
      }

      button {
        width: 100%;
      }
    }
  </style>
</head>
<body>
  <main>
    <header>
      <h1>Kubernetes Demo Control Plane</h1>
      <p id="notifications"></p>
    </header>

    <section id="instance">
      <h2>Instance</h2>
      <div class="status-card instance-card">
        <div class="host-banner">
          <span class="host-label">Hostname</span>
          <span id="hostname">–</span>
        </div>
        <div class="meta-grid">
          <div class="meta-item">
            <span class="meta-label">Started</span>
            <span class="meta-value" id="started">–</span>
          </div>
          <div class="meta-item">
            <span class="meta-label">Uptime</span>
            <span class="meta-value" id="uptime">–</span>
          </div>
          <div class="meta-item">
            <span class="meta-label">Last Updated</span>
            <span class="meta-value" id="last-updated">–</span>
          </div>
        </div>
      </div>
    </section>

    <section id="probes">
      <h2>Probes</h2>
      <div class="grid">
        <div class="probe" data-probe="startup">
          <div class="probe-header">
            <span class="probe-name" title="Startup probe checks whether the container finished initializing before other probes run.">Startup Probe</span>
            <span class="status-chip" id="status-startup">–</span>
          </div>
          <div class="probe-metrics">
            <span id="metrics-startup-calls">Calls: 0</span>
            <span id="metrics-startup-last">Last: –</span>
          </div>
          <div class="flex">
            <label>Downtime minutes
              <input type="number" min="0.1" step="0.5" value="5" id="input-startup-minutes">
            </label>
            <button data-action="down">Take Down</button>
            <button data-action="up" class="secondary">Restore</button>
            <button data-action="ping" class="ghost" type="button">Ping</button>
          </div>
        </div>
        <div class="probe" data-probe="readiness">
          <div class="probe-header">
            <span class="probe-name" title="Readiness probe decides when the pod can start receiving traffic from the service.">Readiness Probe</span>
            <span class="status-chip" id="status-readiness">–</span>
          </div>
          <div class="probe-metrics">
            <span id="metrics-readiness-calls">Calls: 0</span>
            <span id="metrics-readiness-last">Last: –</span>
          </div>
          <div class="flex">
            <label>Downtime minutes
              <input type="number" min="0.1" step="0.5" value="5" id="input-readiness-minutes">
            </label>
            <button data-action="down">Take Down</button>
            <button data-action="up" class="secondary">Restore</button>
            <button data-action="ping" class="ghost" type="button">Ping</button>
          </div>
        </div>
        <div class="probe" data-probe="liveness">
          <div class="probe-header">
            <span class="probe-name" title="Liveness probe tells Kubernetes when to restart the container because it is unhealthy.">Liveness Probe</span>
            <span class="status-chip" id="status-liveness">–</span>
          </div>
          <div class="probe-metrics">
            <span id="metrics-liveness-calls">Calls: 0</span>
            <span id="metrics-liveness-last">Last: –</span>
          </div>
          <div class="flex">
            <label>Downtime minutes
              <input type="number" min="0.1" step="0.5" value="5" id="input-liveness-minutes">
            </label>
            <button data-action="down">Take Down</button>
            <button data-action="up" class="secondary">Restore</button>
            <button data-action="ping" class="ghost" type="button">Ping</button>
          </div>
        </div>
      </div>
    </section>

    <section id="cpu">
      <h2>CPU Stress</h2>
      <div class="status-card">
        <div><strong>Active:</strong> <span id="cpu-active">no</span></div>
        <div><strong>Threads:</strong> <span id="cpu-threads">0</span></div>
        <div><strong>Ends:</strong> <span id="cpu-ends">–</span></div>
      </div>
      <div class="flex" style="margin-top: 0.75rem;">
        <label>Minutes
          <input type="number" min="0.1" step="0.5" value="2" id="cpu-minutes">
        </label>
        <label>Threads
          <input type="number" min="1" step="1" value="4" id="cpu-threads-input">
        </label>
        <button id="cpu-start">Start CPU Stress</button>
        <button id="cpu-stop" class="secondary">Stop CPU Stress</button>
      </div>
    </section>

    <section id="memory">
      <h2>Memory Stress</h2>
      <div class="status-card">
        <div><strong>Active:</strong> <span id="memory-active">no</span></div>
        <div><strong>Target MB:</strong> <span id="memory-target">0</span></div>
        <div><strong>Ends:</strong> <span id="memory-ends">–</span></div>
      </div>
      <div class="flex" style="margin-top: 0.75rem;">
        <label>Minutes
          <input type="number" min="0.1" step="0.5" value="1" id="memory-minutes">
        </label>
        <label>Target (MB)
          <input type="number" min="64" step="64" value="1024" id="memory-target-input">
        </label>
        <button id="memory-start">Start Memory Stress</button>
        <button id="memory-stop" class="secondary">Stop Memory Stress</button>
      </div>
    </section>
  </main>

  <script>
    const notificationEl = document.getElementById('notifications');
    const logStyles = {
      info: 'color:#38bdf8;font-weight:600;',
      success: 'color:#34d399;font-weight:600;',
      warn: 'color:#fbbf24;font-weight:600;',
      error: 'color:#f87171;font-weight:600;'
    };

    function logEvent(level, message, details) {
      const style = logStyles[level] ?? logStyles.info;
      const prefix = '%c[K8sDemo]';
      const logger = level === 'error' ? console.error : level === 'warn' ? console.warn : console.log;
      if (details !== undefined) {
        logger(prefix, style, message, details);
      } else {
        logger(prefix, style, message);
      }
    }

    let currentHostKey = null;

    function setNotification(message, isError = false) {
      if (!message) {
        notificationEl.textContent = '';
        notificationEl.style.color = '';
        return;
      }

      notificationEl.textContent = message;
      notificationEl.style.color = isError ? '#f87171' : '#86efac';
      logEvent(isError ? 'error' : 'success', message);
    }

    function formatDate(value) {
      if (!value) {
        return '–';
      }

      const date = new Date(value);
      if (Number.isNaN(date.getTime())) {
        return '–';
      }

      return date.toLocaleString();
    }

    function formatDuration(value) {
      if (!value) {
        return '–';
      }

      if (typeof value === 'number') {
        if (!Number.isFinite(value) || value < 0) {
          return '–';
        }
        const totalSeconds = Math.floor(value);
        const hrs = Math.floor(totalSeconds / 3600).toString().padStart(2, '0');
        const mins = Math.floor((totalSeconds % 3600) / 60).toString().padStart(2, '0');
        const secs = Math.floor(totalSeconds % 60).toString().padStart(2, '0');
        return `${hrs}:${mins}:${secs}`;
      }

      if (typeof value === 'string') {
        return value;
      }

      return '–';
    }

    function formatProbeLabel(probe) {
      if (!probe) {
        return 'Probe';
      }
      return probe.charAt(0).toUpperCase() + probe.slice(1);
    }

    function applyHostTheme(hostname) {
      if (!hostname || hostname === currentHostKey) {
        return;
      }

      currentHostKey = hostname;
      const hue = computeHostHue(hostname);
      const primary = `hsl(${hue} 78% 58%)`;
      const glow = `hsla(${hue} 90% 65% / 0.35)`;
      const surface = `hsla(${hue} 38% 18% / 0.82)`;
      const border = `hsla(${hue} 40% 65% / 0.28)`;
      const dark = `hsl(${hue} 58% 11%)`;
      const darker = `hsl(${hue} 60% 7%)`;
      const chip = `hsla(${hue} 85% 62% / 0.22)`;
      const chipBorder = `hsla(${hue} 85% 68% / 0.48)`;
      const button = `hsl(${hue} 80% 55%)`;
      const buttonHover = `hsl(${hue} 86% 60%)`;

      const root = document.documentElement.style;
      root.setProperty('--host-color-primary', primary);
      root.setProperty('--host-color-glow', glow);
      root.setProperty('--host-color-surface', surface);
      root.setProperty('--host-color-border', border);
      root.setProperty('--host-color-dark', dark);
      root.setProperty('--host-color-darker', darker);
      root.setProperty('--host-color-chip', chip);
      root.setProperty('--host-color-chip-border', chipBorder);
      root.setProperty('--host-color-button', button);
      root.setProperty('--host-color-button-hover', buttonHover);
      logEvent('info', 'Theme updated for host', { hostname, hue });
    }

    function computeHostHue(hostname) {
      let hash = 0;
      for (let i = 0; i < hostname.length; i++) {
        hash = (hash << 5) - hash + hostname.charCodeAt(i);
        hash |= 0;
      }
      return Math.abs(hash) % 360;
    }

    function updateInstance(data) {
      document.getElementById('hostname').textContent = data.hostname ?? '–';
      document.getElementById('started').textContent = formatDate(data.startedAtUtc);
      document.getElementById('uptime').textContent = formatDuration(data.uptime);
      const sequence = typeof data.sequence === 'number' ? ` #${data.sequence}` : '';
      document.getElementById('last-updated').textContent = `${new Date().toLocaleTimeString()}${sequence}`;
      if (typeof data.sequence === 'number') {
        logEvent('info', `Status heartbeat received (seq ${data.sequence})`, {
          hostname: data.hostname,
          uptime: formatDuration(data.uptime)
        });
      }
    }

    function updateProbes(data) {
      const probes = data.probes || {};
      ['startup', 'readiness', 'liveness'].forEach(name => {
        const info = probes[name];
        const el = document.getElementById(`status-${name}`);
        const countEl = document.getElementById(`metrics-${name}-calls`);
        const lastEl = document.getElementById(`metrics-${name}-last`);
        if (!el) {
          return;
        }

        if (!info) {
          el.className = 'status-chip down';
          el.textContent = 'Unknown';
          if (countEl) {
            countEl.textContent = 'Calls: –';
          }
          if (lastEl) {
            lastEl.textContent = 'Last: –';
          }
          return;
        }

        el.className = `status-chip ${info.healthy ? 'up' : 'down'}`;
        if (info.healthy) {
          el.textContent = 'Up';
        } else if (info.downUntilUtc) {
          el.textContent = `Down until ${formatDate(info.downUntilUtc)}`;
        } else {
          el.textContent = 'Down';
        }

        if (countEl) {
          const count = typeof info.callCount === 'number' && info.callCount >= 0 ? info.callCount : '–';
          countEl.textContent = `Calls: ${count}`;
        }

        if (lastEl) {
          const last = info.lastCalledUtc ? formatDate(info.lastCalledUtc) : '–';
          lastEl.textContent = `Last: ${last}`;
        }
      });
    }

    function updateCpu(data) {
      const cpu = (data.stress && data.stress.cpu) || {};
      document.getElementById('cpu-active').textContent = cpu.active ? 'yes' : 'no';
      document.getElementById('cpu-threads').textContent = cpu.threadCount ?? 0;
      const ends = cpu.active ? cpu.expectedCompletionUtc : cpu.completedAtUtc;
      document.getElementById('cpu-ends').textContent = ends ? formatDate(ends) : '–';
    }

    function updateMemory(data) {
      const memory = (data.stress && data.stress.memory) || {};
      document.getElementById('memory-active').textContent = memory.active ? 'yes' : 'no';
      document.getElementById('memory-target').textContent = memory.targetMegabytes ?? 0;
      const ends = memory.active ? memory.expectedCompletionUtc : memory.completedAtUtc;
      document.getElementById('memory-ends').textContent = ends ? formatDate(ends) : '–';
    }

    async function postJson(url, payload) {
      const response = await fetch(url, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      });

      if (!response.ok) {
        const error = await safeReadJson(response);
        const message = error?.message || `Request failed (${response.status})`;
        throw new Error(message);
      }

      return safeReadJson(response);
    }

    async function deleteRequest(url) {
      const response = await fetch(url, { method: 'DELETE' });
      if (!response.ok) {
        const error = await safeReadJson(response);
        const message = error?.message || `Request failed (${response.status})`;
        throw new Error(message);
      }

      return safeReadJson(response);
    }

    async function safeReadJson(response) {
      try {
        return await response.json();
      } catch (_) {
        return null;
      }
    }

    async function pingProbe(probe) {
      const label = formatProbeLabel(probe);
      try {
        const response = await fetch(`/health/${probe}`);
        const payload = await safeReadJson(response);
        const rawStatus = typeof payload?.status === 'string' ? payload.status.toLowerCase() : null;
        const healthy = response.ok && rawStatus === 'ok';
        const friendly = healthy
          ? 'healthy'
          : rawStatus === 'down'
            ? 'unhealthy'
            : rawStatus ?? `status ${response.status}`;
        const message = `${label} probe responded ${friendly}.`;
        setNotification(message, !healthy);
        logEvent(healthy ? 'success' : 'warn', `${label} probe ping`, {
          statusCode: response.status,
          payload
        });
      } catch (error) {
        setNotification(`Failed to call ${label.toLowerCase()} probe: ${error.message}`, true);
        logEvent('error', `${label} probe ping failed`, { error: error.message });
      }
    }

    function getMinutesInput(id) {
      const value = parseFloat(document.getElementById(id).value);
      if (!Number.isFinite(value) || value <= 0) {
        throw new Error('Minutes must be a positive number.');
      }
      return value;
    }

    function bindProbeControls() {
      document.querySelectorAll('#probes .probe').forEach(container => {
        const probe = container.dataset.probe;
        const minutesInput = document.getElementById(`input-${probe}-minutes`);
        const label = formatProbeLabel(probe);

        container.querySelectorAll('button').forEach(button => {
          button.addEventListener('click', async () => {
            if (button.dataset.action === 'ping') {
              await pingProbe(probe);
              return;
            }

            try {
              if (button.dataset.action === 'down') {
                const minutes = getMinutesInput(minutesInput.id);
                await postJson(`/api/probes/${probe}/down`, { minutes });
                setNotification(`${label} probe taken down for ${minutes} minute(s).`);
                logEvent('warn', `${probe} probe scheduled down`, { minutes });
              } else if (button.dataset.action === 'up') {
                await postJson(`/api/probes/${probe}/up`, {});
                setNotification(`${label} probe restored.`);
                logEvent('success', `${probe} probe restored`);
              }
            } catch (error) {
              setNotification(error.message, true);
            }
          });
        });
      });
    }

    function bindStressControls() {
      document.getElementById('cpu-start').addEventListener('click', async () => {
        try {
          const minutes = getMinutesInput('cpu-minutes');
          const threads = parseInt(document.getElementById('cpu-threads-input').value, 10);
          if (!Number.isFinite(threads) || threads <= 0) {
            throw new Error('Threads must be a positive integer.');
          }
          await postJson('/api/stress/cpu', { minutes, threads });
          setNotification(`CPU stress scheduled for ${minutes} minute(s) with ${threads} thread(s).`);
          logEvent('warn', 'CPU stress scheduled', { minutes, threads });
        } catch (error) {
          setNotification(error.message, true);
        }
      });

      document.getElementById('cpu-stop').addEventListener('click', async () => {
        try {
          await deleteRequest('/api/stress/cpu');
          setNotification('CPU stress cancelled.');
          logEvent('success', 'CPU stress cancelled');
        } catch (error) {
          setNotification(error.message, true);
        }
      });

      document.getElementById('memory-start').addEventListener('click', async () => {
        try {
          const minutes = getMinutesInput('memory-minutes');
          const target = parseInt(document.getElementById('memory-target-input').value, 10);
          if (!Number.isFinite(target) || target <= 0) {
            throw new Error('Target megabytes must be greater than zero.');
          }
          await postJson('/api/stress/memory', { minutes, targetMegabytes: target });
          setNotification(`Memory stress scheduled for ${minutes} minute(s) at ${target} MB.`);
          logEvent('warn', 'Memory stress scheduled', { minutes, targetMegabytes: target });
        } catch (error) {
          setNotification(error.message, true);
        }
      });

      document.getElementById('memory-stop').addEventListener('click', async () => {
        try {
          await deleteRequest('/api/stress/memory');
          setNotification('Memory stress cancelled.');
          logEvent('success', 'Memory stress cancelled');
        } catch (error) {
          setNotification(error.message, true);
        }
      });
    }

    let eventSource;
    let reconnectTimer;

    function applyStatus(data) {
      applyHostTheme(data.hostname);
      updateInstance(data);
      updateProbes(data);
      updateCpu(data);
      updateMemory(data);
      setNotification('');
    }

    function connectStream() {
      clearTimeout(reconnectTimer);

      if (eventSource) {
        eventSource.close();
      }

      eventSource = new EventSource('/api/status/stream');

      eventSource.onopen = () => {
        setNotification('Connected', false);
        logEvent('success', 'Connected to status stream');
      };

      eventSource.onmessage = event => {
        try {
          const data = JSON.parse(event.data);
          applyStatus(data);
        } catch (error) {
          setNotification(`Failed to parse status update: ${error.message}`, true);
          logEvent('error', 'Status payload parse failed', { raw: event.data });
        }
      };

      eventSource.onerror = () => {
        eventSource.close();
        setNotification('Connection lost. Reconnecting…', true);
        logEvent('warn', 'Status stream disconnected, retrying in 3s');
        reconnectTimer = setTimeout(connectStream, 3000);
      };
    }

    function initializeInputs() {
      const cores = navigator.hardwareConcurrency || 4;
      document.getElementById('cpu-threads-input').value = Math.min(cores * 2, 16);
    }

    document.addEventListener('DOMContentLoaded', () => {
      logEvent('info', 'Bootstrapping dashboard');
      initializeInputs();
      bindProbeControls();
      bindStressControls();
      connectStream();
    });
  </script>
</body>
</html>
